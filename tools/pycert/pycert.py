# Python SSL certificate conversion tool.
# Download and converts SSL certs from PEM format into a C header that can be
# referenced from a sketch to load the certificate data (in binary DER format).
# Author: Tony DiCola
#
# Dependencies:
#   click - Install with 'sudo pip install click' (omit sudo on windows)
#
# No other dependencies other than Python!  In particular this tool does _not_
# use OpenSSL and instead uses Python's built in SSL library functions.
import os
import ssl
import textwrap

import click

# Default values:
CERT_LEN_VAR_DEFAULT = 'ROOTCA_CERTS_LEN'  # Cert data length variable name.
CERT_VAR_DEFAULT = 'rootca_certs'          # Cert data variable name.

# Template that defines the C header output format.
# This takes in a few named parameters:
#  - guard_name: Unique name to apply to the #ifndef header guard.
#  - cert_length_var: Variable/define name for the length of the certificate.
#  - cert_length: Length of the certificate (in bytes).
#  - cert_var: Variable name for the certificate data.
#  - cert_data: Certificate data (must be in comma separated hex format).
# NOTE: If you're changing the template make sure to escape all curly braces
# with a double brace (like {{ or }}) or else Python will try to interpret as a
# string format variable.
CFILE_TEMPLATE = """
#ifndef _{guard_name}_H_
#define _{guard_name}_H_

#ifdef __cplusplus
extern "C"
{{
#endif

/* This file is auto-generated by the pycert tool.  Do not change it manually.
   Certificates are in DER (binary) format. */
#define {cert_length_var} {cert_length}
const uint8_t {cert_var}[{cert_length_var}] = {{
{cert_data}
}};

#ifdef __cplusplus
}} /* extern "C" */
#endif

#endif /* ifndef _{guard_name}_H_ */
"""

# Useful helper functions:
def DER_to_header(cert_der, output_file, cert_var, cert_length_var):
    """Convert a binary DER format certificate into a C header that will
    import and expose the certificate to a sketch.  Cert_der should be a binary
    DER format certificate, and output_file should be a file that is open for
    writing and will receive the result header file data.
    """
    # Build up the header template text parameters for the output.
    params = {}
    # Set header guard to output file name in uppercase and without .h extension.
    params['guard_name'] = os.path.splitext(output_file.name)[0].upper()
    # Set other template values.
    params['cert_length_var'] = cert_length_var
    params['cert_var'] = cert_var
    params['cert_length'] = len(cert_der)
    # Convert DER to hex byte string with each byte separated by a comma
    # (so it can be used in an array definition).
    cert_hex = ', '.join(['0x{0:02X}'.format(x) for x in cert_der])
    # Set cert data to hex string (wrapped nicely on 80 character boundary).
    params['cert_data'] = textwrap.fill(cert_hex, width=80, break_long_words=False,
        break_on_hyphens=False, initial_indent='  ', subsequent_indent='  ')
    output_file.write(CFILE_TEMPLATE.format(**params))

def PEM_split(cert_pem):
    """Split a certificate / certificate chain in PEM format into multiple
    PEM certificates.  This is useful for extracting the last / root PEM cert
    in a chain for example.  Will return a list of strings with each string
    being an individual PEM certificate (including its '-----BEGIN CERTIFICATE...'
    delineaters).
    """
    # Split cert based on begin certificate sections, then reconstruct as an
    # array of individual cert strings.
    delineator = '-----BEGIN CERTIFICATE-----'
    return ["{0}{1}".format(delineator, x) for x in cert_pem.split(delineator)]

def PEM_to_header(pems, cert_var, cert_length_var, output, full_chain):
    """Combine a collection of PEM format certificates into a single C header
    with the combined cert data in binary DER format.  Pems should be a list of
    strings with each cert PEM, cert_var controls the name of the cert data
    variable in the output header, cert_length_var controls the name of the cert
    data length variable/define, output is the output file (which must be open
    for writing), and full_chain is a boolean that indicates if each cert should
    include the full chain or just the root/last cert.
    """
    cert_der = bytearray()
    for p in pems:
        # Parse out the root/last cert if requested.
        if not full_chain:
            p = PEM_split(p)[-1]
        # Convert PEM to binary DER format and add to result.
        cert_der.extend(bytearray(ssl.PEM_cert_to_DER_cert(p)))
    # Save DER as a C style header.
    DER_to_header(cert_der, output, cert_var, cert_length_var)
    click.echo('Wrote {0}'.format(output.name))


# Click setup and commands:
@click.group()
def pycert():
    """Adafruit Python Certificate Tool

    This is a tool to download and convert SSL certificates and certificate
    chains into a C header format that can be imported into WICED board sketches.
    """
    pass

@pycert.command(short_help='Download SSL certs and save as a C header.')
@click.option('--port', '-p', type=click.INT, default=443,
              help='port to use for reading certificate (default 443, SSL)')
@click.option('--cert-var', '-c', default=CERT_VAR_DEFAULT,
              help='name of the variable in the header which will contain certificate data (default: {0})'.format(CERT_VAR_DEFAULT))
@click.option('--cert-length-var', '-l', default=CERT_LEN_VAR_DEFAULT,
              help='name of the define in the header which will contain the length of the certificate data (default: {0})'.format(CERT_LEN_VAR_DEFAULT))
@click.option('--output', '-o', type=click.File('w'), default='certificates.h',
              help='name of the output file (default: certificates.h)')
@click.option('--full-chain', '-f', is_flag=True, default=False,
              help='use the full certificate chain and not just the root/last cert (default: false, root cert only)')
@click.argument('domain', nargs=-1)
def download(port, cert_var, cert_length_var, output, full_chain, domain):
    """Download the SSL certificates for specified domain(s) and save them as a C
    header file that can be imported into a sketch.

    Provide at least one argument that is the domain to query for its SSL
    certificate, for example google.com for Google's SSL certificate.  You can
    provide any number of domains as additional arguments.  All of the certificates
    will be combined into a single output header.

    By default the file 'certificates.h' will be created, however you can change
    the name of the file with the --output option.

    If a chain of certificates is retrieved then only the root certificate (i.e.
    the last in the chain) will be saved.  However you can override this and
    force the full chain to be saved with the --full-chain option.

    Example of downloading google.com's SSL certificate and storing it in
    certificates.h:

      pycert download google.com

    Example of downloading google.com and adafruit.com's SSL certificates and
    storing them in data.h:

      pycert download --output data.h google.com adafruit.com

    Note that the certificates will be validated before they are downloaded!
    """
    # Download the cert PEM for each provided domain.
    pems = []
    for d in domain:
        # Download the certificate (unfortunately python will _always_ try to
        # validate it so we have no control over turning that off).
        cert_pem = ssl.get_server_certificate((d, port))
        if cert_pem is None or cert_pem == '':
            raise click.ClickException('Could not download and/or validate the certificate for {0} port {1}!'.format(d, port))
        click.echo('Retrieved certificate for {0}'.format(d))
        pems.append(cert_pem)
    # Combine PEMs and write output header.
    PEM_to_header(pems, cert_var, cert_length_var, output, full_chain)


@pycert.command(short_help='Convert PEM certs into a C header.')
@click.option('--cert-var', '-c', default=CERT_VAR_DEFAULT,
              help='name of the variable in the header which will contain certificate data (default: {0})'.format(CERT_VAR_DEFAULT))
@click.option('--cert-length-var', '-l', default=CERT_LEN_VAR_DEFAULT,
              help='name of the define in the header which will contain the length of the certificate data (default: {0})'.format(CERT_LEN_VAR_DEFAULT))
@click.option('--output', '-o', type=click.File('w'), default='certificates.h',
              help='name of the output file (default: certificates.h)')
@click.option('--full-chain', '-f', is_flag=True, default=False,
              help='use the full certificate chain and not just the root/last cert (default: false, root cert only)')
@click.argument('cert', type=click.File('r'), nargs=-1)
def convert(cert_var, cert_length_var, output, full_chain, cert):
    """Convert PEM certificates into a C header that can be imported into a
    sketch.  Specify each certificate to encode as a separate argument (each
    must be in PEM format) and they will be merged into a single file.

    By default the file 'certificates.h' will be created, however you can change
    the name of the file with the --output option.

    If a chain of certificates is found then only the root certificate (i.e.
    the last in the chain) will be saved.  However you can override this and
    force the full chain to be saved with the --full-chain option.

    Example of converting a foo.pem certificate into a certificates.h header:

      pycert convert foo.pem

    Example of converting foo.pem and bar.pem certificates into data.h:

      pycert convert foo.pem bar.pem
    """
    # Load all the provided PEM files.
    pems = []
    for c in cert:
        cert_pem = c.read()
        click.echo('Loaded certificate {0}'.format(c.name))
        pems.append(cert_pem)
    # Combine PEMs and write output header.
    PEM_to_header(pems, cert_var, cert_length_var, output, full_chain)


if __name__ == '__main__':
    pycert()
