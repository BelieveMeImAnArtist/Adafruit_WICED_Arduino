/*
  HTTPSWithCallback Example:

  1.  Change the directory path to 'https_server'

  2.  Generate the private key and certificate for the HTTPS server (server.pem)
      with the following command:
        $ openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes
      Input the required information to complete the command

  3.  Start the HTTPS server via the python script in 'HTTPSWithCallback/https_server'
        $ sudo python server.py   // port 443 - require root privileges
        or
        $ python server.py 4443   // port 4443

  4.  Make a note of your local IP address (the method to determine your IP
      address will depend on your operating system)

  5.  Generate the certificate file (cert.pem) for client using openssl ultility
        $ echo "" | openssl s_client -connect 192.168.1.1:4443 -showcerts \
          -CApath /etc/ssl/certs | awk '/BEGIN CERT/ {p=1}; p; /END CERT/ {p=0}' > cert.pem

  6.  Generate "certificate.h" from certificate file (cert.pem) using python script
        $ python cert_to_h.py cert.pem ca_cert certificate
      The variable name (ca_cert) and the output file (certificate.h) are used in
      this sketch

  7.  Add your AP details via WLAN_SSID and WLAN_PASS in this sketch

  8.  Add the URL of the HTTPS server you started to the URL in this sketch,
      using the IP address of your machine, the port number of started server
      (optional, default is 443) and the filename to load.
      For example:
        "https://192.168.1.1/text_1KB.txt"        // Default port 443
        "https://192.168.1.1:4443/text.100B.txt"

  9.  Run the example and open serial monitor to see the HTTPS response

  10. Compare the CRC of downloaded file with the CRC generated by 'crc32.py'
      $ python crc32.py <filename>

  author: huynguyen

  CRC code by James Bowman: http://excamera.com/sphinx/article-crc.html
 */

#include "adafruit_feather.h"
#include "certificate.h"

#define WLAN_SSID            "SSID"
#define WLAN_PASS            "PASSWORD"

#define URL                  "https://IPADDRESS:4443/text_1KB.txt"
#define CONTENT              ""
#define METHOD               GET_METHOD


int           wifi_error  = -1;    // FAIL
unsigned long crc         = ~0L;
int           data_found  = 0;

// CRC Lookup table to speed things up
static PROGMEM prog_uint32_t crc_table[16] =
{
  0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
  0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
  0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
  0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
};

/**************************************************************************/
/*!
    @brief  Feeds a byte (data) into the existing CRC32 value (crc)

    @return The updated CRC32 value
*/
/**************************************************************************/
unsigned long crc32_feed(unsigned long crc, byte data)
{
  byte tbl_idx;
  tbl_idx = crc ^ (data >> (0 * 4));
  crc = pgm_read_dword_near(crc_table + (tbl_idx & 0x0f)) ^ (crc >> 4);
  tbl_idx = crc ^ (data >> (1 * 4));
  crc = pgm_read_dword_near(crc_table + (tbl_idx & 0x0f)) ^ (crc >> 4);
  return crc;
}

/**************************************************************************/
/*!
    @brief  Looking for the packet data (ignore the packet header),
            then update the global CRC value
*/
/**************************************************************************/
void crc32_calculation(uint8_t* data)
{
  char* p_data = NULL;
  if (data_found == 0)
  {
    // Check for an empty line where data begins
    p_data = strstr((char*)data, "\r\n\r\n");
    if (p_data != NULL)
    {
      p_data += 4;
      data_found = 1;

      while (*p_data)
        crc = crc32_feed(crc, *p_data++);
    }
  }
  else
  {
    p_data = (char*)data;
    while (*p_data)
      crc = crc32_feed(crc, *p_data++);
  }
}

/**************************************************************************/
/*!
    @brief  Connect to the WLAN_SSID access point using WLAN_PASS

    @return Error code
*/
/**************************************************************************/
int connectAP()
{
  // Attempt to connect to an AP
  Serial.print(F("Attempting to connect to: "));
  Serial.println(WLAN_SSID);

  int error = feather.connectAP(WLAN_SSID, WLAN_PASS);

  if (error == 0)
  {
    Serial.println(F("Connected!"));
  }
  else
  {
    Serial.print(F("Failed! Error: "));
    Serial.println(error, HEX);
  }
  Serial.println("");

  return error;
}

/**************************************************************************/
/*!
    @brief This function is called whenever new data is received from
           the feather.httpsRequestWithCallback function
*/
/**************************************************************************/
void rxCallback(uint8_t* data, uint16_t data_length, uint16_t avail)
{
  // Send the raw payload to the Serial Monitor ...
  Serial.print((char*)data);

  // ... then calculate the CRC32 for the payload until EOF
  crc32_calculation(data);
}

/**************************************************************************/
/*!
    @brief  The setup function runs once when reset the board
*/
/**************************************************************************/
void setup()
{
  // If you want to use LED for debug
  pinMode(BOARD_LED_PIN, OUTPUT);

  // wait for Serial
  while (!Serial) delay(1);

  Serial.println(F("HTTPS With Callback Example\r\n"));

  // Register the callback handler
  feather.addHttpDataReceivedCallBack(rxCallback);

  // Try to connect to the access point
  wifi_error = connectAP();
}

/**************************************************************************/
/*!
    @brief  The loop function runs over and over again forever
*/
/**************************************************************************/
void loop()
{
  // put your main code here, to run repeatedly
  Serial.println(F("Toggle LED"));
  togglePin(BOARD_LED_PIN);

  if (wifi_error == 0)
  {
    int https_error = -1;
    // Start the HTTPS request (this function will block until EOF or ERROR)
    if ( (https_error = feather.httpsRequestWithCallback(URL, ca_cert, CONTENT, METHOD) ) != 0)
    {
      Serial.print(F("Error: "));
      Serial.println(https_error, HEX);
    }
    else
    {
      // Display the CRC32 for the entire payload
      crc = ~crc;
      Serial.print(F("\r\nCRC = "));
      Serial.println(crc, HEX);
    }
  }

  data_found = 0;
  crc = ~0L;
  Serial.println(F("\r\n"));
  delay(10000);
}
